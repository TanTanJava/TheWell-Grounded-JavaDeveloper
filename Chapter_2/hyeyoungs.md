# Chapter02 자바 모듈

## 배경 설명
* 모듈
    * 자바 9부터 도입된 자바 언어의 새로운 개념
    * 런타임에 의미를 가지는 응용 프로그램 배포 및 의존성의 단위
    * 모듈은 모듈 간의 의존성 정보를 정의하므로 컴파일 또는 애플리케이션 시작 시점에서 모든 종류의 해결과 연결 문제를 감지할 수 있음
    * 적절한 캡슐화를 제공해서 내부 패키지와 클래스를 조작하려는 사용자로부터 안전하게 보호할 수 있음
    * 최신 자바 런타임에서 이해하고 사용할 수 있는 메타데이터가 포함된 적절한 배포 단위이며, 자바 타입 시스템에서(예: 리플렉션을 통해) 표현됨
* 모듈 시스템의 목표는 배포 단위(모듈)를 가능한 한 서로 독립적으로 만드는 것
* 비록 실제 애플리케이션은 관련 기능을 제공하는 모듈의 그룹에 종속될 수 있지만, 모듈은 개별적으로 로드 및 링크될 수 있도록 설계

## 기본적인 모듈 구문
* 자바에서 모듈은 module-info.java 파일로 정의됨 
* 이 파일은 모듈의 이름, 공개된 패키지, 의존하는 다른 모듈 등을 명시적으로 선언함

```
module my.module {
    requires java.base; // 다른 모듈 의존성
    exports com.example.mypackage; // 외부에 공개할 패키지
}
```

## 모듈 전이성과 클래스로딩 문제
1. 기존 : 패키지 기반 의존성 및 클래스 로딩
   - 클래스 로딩이 패키지와 JAR 파일을 기반으로 이루어졌음
     - 의존성 연결: JAR 파일에 선언된 클래스 파일을 패키지 경로를 따라 로딩 
     - 클래스 로딩: 클래스 로더가 필요한 시점에 동적으로 클래스를 로딩
2. 모듈 : Java 9부터 도입된 모듈 시스템에서는 클래스를 패키지 단위가 아니라 모듈 단위로 관리함
   - 의존성 그래프: 모듈의 module-info.java 파일에 정의된 모듈 의존성 정보를 기반으로, 클래스로더가 필요한 모듈 간의 관계를 이해함
   - 클래스 로딩: 모듈 의존성 그래프를 기반으로 필요한 모듈을 분리된 단위로 로딩
   - 하지만, 모듈 전체를 로딩하지 않고 필요한 클래스만 골라서 로딩한다는 점은 기존 방식과 동일함
3. 모듈 시스템의 문제: 폭발적인 클래스 의존성
   <br>전이성 설정을 비롯하여 internal 작성이 유도됨에 따라 폭발적인 클래스 의존성이 쉽게 작성되는 경향이 강함
     - 모듈 전이성 : 모듈의 의존성을 전이적으로 선언할 수 있음 
       - 즉, requires transitive 키워드를 통해 특정 모듈의 의존성을 다른 모듈이 암묵적으로 상속받도록 설정할 수 있음 
       - 문제점: 이런 방식으로 작성된 전이적 의존성은 의도치 않게 의존성 그래프가 복잡해지고, 결과적으로 불필요한 클래스 간 의존성이 추가됨
    ```
    module A {
        requires transitive B;
    }
    
    module C {
        requires A; // 모듈 C는 B에도 의존하게 됨
    }
    ```
   - Internal 작성 유도 
     - 모듈 시스템은 외부로 노출하지 않는 패키지를 명시적으로 정의하여 내부 구현을 캡슐화하도록 권장함 
     - 하지만, 잘못 설계된 모듈은 내부 구현이 외부와 과도하게 얽혀 클래스 간 결합도가 증가할 수 있음
    
## 모듈 캐노니컬에 대해
1. 기존 : 클래스 캐노니컬 충돌이 생김
2. 모듈 : 모듈 캐노니컬 충돌이 생김
3. 기존의 해결 방식 : 클래스 로더를 분리하여 각각 로딩할 수 있음
4. 모듈의 해결 방식 : 없음. 직소는 모든 모듈을 하나의 이름공간으로 관리

## 모듈 무용론
1. 모듈시스템에서 식별은 모듈캐노니컬에 기반함으로 원래는 모든 패키지는 모듈만 다르면 똑같이 사용해도 무방함
2. 하지만 무명모듈과 자동모듈의 작동이 기존 자바8과의 호환성을 바탕으로 하기 때문에 실제로는 모듈 시스템도 클래스 캐노니컬이 적용됨
3. 오히려 과거 같은 패키지가 클래스로더 분할로 로딩할 수 있었던 것과 비교하여 모듈이 달라도 패키지가 전부 달라야하기 때문에 더 후퇴됨
4. 많은 병행패키지 전략이나 버전 jar 전략이 모듈에서 전혀 안통함
5. 자바 코어를 제외한 모듈 기반의 생태계는 거의 황폐함
6. 코틀린을 비롯한 jvm호환언어도 대부분 모듈 무시 중
7. 그냥 jvm내장 클래스라이브러리를 필요한 것만 로딩할 수 있다 정도

## 모듈을 넘어서
### jlink
- jlink는 Java 9에서 도입된 도구로, 
<br>특정 애플리케이션을 실행하는 데 필요한 자바 런타임 환경(JRE)을 `커스터마이징`하고 
<br>`축소된 런타임 이미지`를 생성하는 기능을 제공함
<br>이를 통해 필요한 모듈만 포함한 런타임을 애플리케이션과 함께 배포할 수 있음

- 장점
    - 설치형 프로그램을 만들기 좋음
        - 축소된 런타임은 애플리케이션과 함께 배포할 수 있어 별도의 JDK 또는 JRE 설치가 필요 없음
        - jpackage와 함께 사용하면 .msi, .dmg 같은 설치형 파일을 생성할 수 있음
    - 애플리케이션 크기 축소
        - 불필요한 모듈과 클래스를 포함하지 않으므로 디스크 공간을 절약하고 배포 크기를 줄임
    - 독립 실행형 배포 가능
        - 축소된 런타임은 애플리케이션과 함께 배포할 수 있어 별도의 JDK 또는 JRE 설치가 필요 없음
- 한계 
  - 운영 체제별 서명 및 메타정보 미지원 
    - jlink는 단순히 축소된 런타임 이미지를 생성하며, 운영 체제별로 필요한 서명(signing) 또는 메타데이터(metadata) 작업은 지원하지 않음 
    - 이러한 작업은 추가적으로 jpackage 같은 도구를 통해 처리해야 함
  - 자동 모듈(Auto Module)의 문제 
    - 자동 모듈은 모듈 시스템에 완전히 적응하지 않은 라이브러리를 기존의 jar 파일로 포함시킬 때 사용됨 
    - 하지만, 이 방식은 모듈 의존성을 명확히 정의하지 않고 암묵적으로 포함하기 때문에 "모듈 쓰레기"를 만들 가능성이 높음 
      - 문제점: 의존성 충돌, 모듈 분리 실패, 예상치 못한 런타임 오류 
