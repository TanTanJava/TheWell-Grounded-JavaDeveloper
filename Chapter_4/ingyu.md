- 클래스 로딩은 JVM이 실행 중인 프로그램에서 새로운 타입을 찾아 활성화하는 과정

### 클래스 로딩과 클래스 객체

- .class 파일은 필드, 메서드, 상속 정보, 애너테이션, 기타 메타데이터로 구성된 JVM에서의 타입을 정의한다.
- 개발자가 실행 가능한 JAR 파일이나 기본 애플리케이션 클래스의 이름을 제공하면 JVM 이 해당 클래스를 찾아 실행한다.

```jsx
Class<?> clazz = Class.forName("MyClass")
```

MyClass 라는 이름에 해당하는 클래스 파일을 찾은 다음 해당 파일에 포함된 클래스를 해석한다. 

- JVM은 클래스 파일을 읽어 내부 자료구조(klass)를 만들고, 그 정보를 이용해 자바에서 사용할 수 있는 Class 객체(자바 미러)를 생성한 뒤 자바 코드에 전달

*klass = 클래스의 메타 정보에 대한 참조를 저장해둔 데이터 단위

- clazz는 MyClass 타입에 해당하는 Class 객체를 보유한다. 그러나 klass 는 자바 객체가 아닌 JVM 내부 객체여서 clazz가 보유할 수 없다.

### 로딩과 링킹

- 파일 시스템에서 클래스 파일의 바이트 배열(데이터 스트림)을 읽어오고,  이 스트림을 파싱하여 올바른 클래스 파일 구조인지 확인하고, 유효하면 후보 klass를 생성
- 클래스를 링크한 후 초기화해야 사용할 수 있다.
- **검증단계 -** 클래스 파일의 구조와 내용이 올바른지 확인
- **준비 -** 클래스 변수들을 위한 메모리 공간을 할당하고 기본값을 설정
- **해결 -** 다른 클래스나 메서드에 대한 참조들을 실제 주소나 객체와 연결
- **초기화 -** static 블록이나 필드 초기화 코드를 실행하여 클래스가 사용 가능한 상태로 준비

초기화 단계에서 모든 정적 변수가 초기화 되고 모든 정적 초기화 블록이 실행된다.

JVM이 새로 로드된 클래스의 바이트코드를 실행한다. 

### Class 객체

- 로딩과 링킹 프로세스의 최종 결과는 새로 로드되고 링크된  타입을 나타내는 Class 객체다.
- Class 객체는 메서드, 필드, 생성자 등에 간접적인 액세스를 위해 리플렉션 API 함께 사용할 수 있다.

### 클래스 로더

- 클래스 로더는 JVM 내부에서 필요한 클래스 파일(.class)을 찾아 메모리에 로딩하고, 이를 실행 가능한 형태(자바의 Class 객체)로 변환하는 역할
    - BootstrapClassLoader
        - JVM의 핵심 라이브러리(예: rt.jar)를 로드하는 기본 클래스 로더
    - PlatformClassLoader
        - **PlatformClassLoader**는 자바 플랫폼에서 제공하는 추가 모듈이나 라이브러리를 로드
    - AppClassLoader
        - **AppClassLoader**는 애플리케이션에서 사용하는 클래스들을 로드

### 사용자 정의 클래스 로드

- Java.lang.ClassLoader 서브클래싱하는 여러 사용자 정의 클래스로더 클래스를 추가할 수 있다.
- loadClass() 는 클래스 로딩의 전체 프로세스를 관리한다.
- 커스텀 클래스 로더를 만들 때는 보통 `findClass()`만 오버라이드한다.

### 클래스 로드 중 발생할 수 있는 예외들

- ClassNotFoundException
- 자바에서 클래스를 동적으로 로드하려고 할 때, 해당 클래스의 정의를 찾지 못하면 발생하는 예외
- 체크 예외(checked exception)이므로, 반드시 예외 처리가 필요함
- JVM은 클래스 로드에 실패하면 그 실패 결과(즉, 해당 클래스가 없다는 사실)를 캐시에 저장한다. → **네거티브 캐싱**
    - 클래스에 대해 반복적으로 로드를 시도하지 않고, 캐시에 저장된 실패 정보를 바탕으로 즉시ClassNotFoundException을 던져 성능을 최적화하는 역할

### 첫 번째 사용자 정의 클래스로더

- 클래스 로더를 서브클래싱하여 findClass()를 오버라이드하는 것은 커스텀 클래스 로더를 만드는 전형적인 방법
- Java의 ClassLoader에 정의된 **defineClass()** 메서드는 클래스 파일의 바이트 배열을 받아 실제 JVM에서 사용 가능한 Class 객체로 정의하는 역할

### DI 프레임워크

- 런타임 와이어링은 애플리케이션이 실행되는 도중에 필요한 구성 요소나 의존성을 동적으로 연결하는 과정을 의미
- 동적 클래스 로딩
    - 커스텀 클래스로더가 지정된 경로 jar 파일 스캔
    - @Component @Service 설정 파일을 기준으로 로드할 클래스를 결정
    - 커스텀 클래스로더를 오버라이드해서 필요한 클래스를 선택적으로 로드
- 의존성 분석
    - 로드된 클래스를 리플렉션을 통해 분석
    - 클래스 내 생성자, 필드, 메서드 등에 붙은 어노테이션 설정 정보 읽어 어떤 의존성을 주입해야 하는지 파악
- 객체 생성 및 와이어링
    - DI컨테이너가 각 클래스의 인스턴스를 생성
    - 생성된 인스턴스들 간에 필요한 의존성을 주입
    - 클래스로드에 의해 로드된 클래스 정보를 사용해 인스턴스 생성과 의존성 주입
- 동적 모듈 업데이트
    - 실행중에 새로운 모듈 클래스가 추가되면 커스텀 클래스로더를 통해 해당 클래스 동적으로 로드하고 DI 컨테이너가 다시 의존성 주입할 수 있도록 처리

### 클래스 파일 살펴보기

- **javap**는 JDK에 포함된 명령줄 도구로, 컴파일된 Java 클래스 파일(.class)을 역어셈블리(disassemble)하여 클래스의 구조와 바이트코드(bytecode)를 사람이 읽을 수 있는 형태로 출력
- 바이트코드를 볼 수있다.

```jsx
javap -c MyClass
```

### 메서드 시그니처를 위한 내부 형식

- 타입 기술자는 JVM이 클래스 파일 내에 타입 정보를 인코딩하고 해석하는데 사용하는 규약
- 자바의 원시 타입이나 참조 타입, 배열 타입을 특정한 기호와 형식으로 표현

원시 타입

- int → **I**
- byte → **B**
- char → **C**
- boolean → **Z**
- double → **D**
- float → **F**
- long → **J**
- short → **S**

### 상수 풀

- Java 클래스 파일 내부에 포함된 "상수"들의 모음집이다.
- 상수들은 컴파일 시 결정된 값이다.
- 코드에 "Hello"라는 문자열 리터럴이 여러 번 사용된다면, 상수 풀에는 "Hello"가 한 번만 저장되고, 해당 문자열을 참조할 때마다 이 상수 풀의 값을 재사용
- 메모리 효율성과 실행 속도를 높이는 역할

### 바이트 코드

- 바이트코드는 자바 소스 코드 파일에서 javac 에 의해 생성된다.

### 클래스 분해하기

- -c 스위치와 함께 javap 를 사용하면 클래스를 분해할 수 있다.
- 클래스 파일 내부에 포함된 메서드, 필드, 생성자 등의 정보를 단순히 나열하는 것뿐 아니라, 각 메서드의 실행 흐름(바이트코드)를 확인

```jsx
javap -c MyClass
```

```jsx
Compiled from "MyClass.java"
public class MyClass {
  public MyClass();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public void hello();
    Code:
       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
       3: ldc           #3                  // String Hello, World!
       5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
       8: return
}
```

### 런타임 환경

- 평가 스택은 JVM(자바 가상 머신)에서 바이트코드 실행 시 사용하는 **피연산자 스택(operand stack)** 을 의미
- JVM은 호출 스택의 각 프레임 내에 평가 스택을 마련해두고, 이곳에 연산에 필요한 중간 값이나 결과값을 저장
- JVM에서 각 자바 스레드마다 생성되는 호출 스택(또는 실행 스택)은, 그 스레드에서 실행되는 메서드 호출 정보를 관리하는 메모리 영역
- 평가 스택은 각 메서드의 실행 컨텍스트 내에서 중간 계산 값을 처리하기 위한 영역이고, 호출 스택은 실행 중인 모든 스레드에서 어떤 메서드들이 호출되었는지, 현재 어떤 메서드가 실행 중인지 기록하는 영역

### 오퍼레이션 코드 소개

- JVM 바이트코드는 실행할 명령어(opcode)와 그 명령어에 필요한 추가 데이터(operand)들을 연속적으로 나열한 형태
- **Name (이름):**
    - 각 바이트코드 명령어의 고유한 식별자 또는 약칭
- **Args (인자 수):**
    - 해당 명령어가 실행될 때, 뒤따라야 하는 인수(operand)의 개수나 타입
- **인수 (Operands):**
    - 실제 명령어의 동작에 필요한 데이터 값들을 의미

### load 및 store 오퍼레이션 코드

- JVM 바이트코드에서 **load** 및 **store** 오퍼레이션 코드는 데이터를 평가 스택과 로컬 변수 배열 간에 이동시키는 역할

### 주요 산술 오퍼레이션 코드

- **정수형 연산 (int):**
    - **iadd:** 정수 덧셈(스택의 두 값을 꺼내어 더한 후 결과를 스택에 푸시)
    - **isub:** 정수 뺄셈(두 값을 꺼내어 뺄셈을 수행)
    - **imul:** 정수 곱셈(두 값을 곱함)
    - **idiv:** 정수 나눗셈(두 값을 나누어 몫을 계산)
    - **irem:** 정수 나머지(나눗셈의 나머지를 계산)
    - **ineg:** 정수 부호 반전(스택의 값을 부호 변경)
    - **iinc:** 로컬 변수에 대한 정수 1증가(특정 로컬 변수의 값을 증가시키는 특수한 명령어)
- **long 연산:**
    - **ladd, lsub, lmul, ldiv, lrem, lneg**
- **float 연산:**
    - **fadd, fsub, fmul, fdiv, frem**
- **double 연산:**
    - **dadd, dsub, dmul, ddiv, drem**

### 실행 흐름을 제어하기 위한 오퍼레이션 코드

- 실행 흐름 제어 오퍼레이션 코드는 JVM 바이트코드에서 프로그램의 실행 경로를 바꾸거나 분기하는 명령어

**조건 분기 (Conditional Branch) 명령어:**

- **if_eq, if_ne, if_lt, if_ge, if_gt, if_le:**평가 스택의 값을 검사하여, 해당 조건(예: 0과의 비교)이 만족되면 지정된 바이트코드 주소로 분기플랫폼 관련 작업을 수행하는 오퍼레이션 코드는?

### invoke 오퍼레이션 코드

**invokevirtual**

- 인스턴스 메서드(일반적인 가상 메서드)를 호출할 때 사용
- 동적 바인딩(dynamic dispatch)을 수행하여, 실행 시 객체의 실제 타입에 따라 오버라이드된 메서드를 선택

**invokespecial**

- 생성자, private 메서드, 또는 상위 클래스의 메서드를 호출할 때 사용
- 동적 바인딩이 적용되지 않으며, 컴파일 타임에 결정된 특정 메서드를 직접 호출

**invokestatic**

- 정적 메서드를 호출할 때 사용
- 호출 시 실제 객체가 구현한 메서드가 실행되며, 동적 바인딩을 통해 적절한 구현체의 메서드가 선택

**invokedynamic** (Java 7부터 도입)

- 동적 언어 지원을 위해, 런타임에 메서드 바인딩을 결정하는 호출에 사용
- 런타임 시점에 콜 사이트(call site)를 동적으로 연결하여, 보다 유연한 메서드 호출이 가능

*call site = 실행 시점에 부트스트랩 메서드를 통해 해당 호출 지점에 적절한 메서드 핸들을 찾아 메서드 호출을 동적으로 수행

### 리플렉션

- 리플렉션은 로드된 클래스의 정보를 조사하고, 인스턴스를 생성하거나 메서드를 호출하는 등의 작업을 런타임에 수행
- 리플렉션을 이용하면, 클래스의 메서드, 필드, 생성자 등에 접근하여 동적으로 조작

### 리플렉션 & 클래스 로더

- 커스텀 클래스 로더로 특정 클래스를 동적으로 로드한 후, 리플렉션을 통해 해당 클래스의 생성자를 호출하여 인스턴스를 생성
- 로드된 클래스의 메서드 정보를 리플렉션으로 획득한 후, 메서드를 호출하여 동작을 변경하거나 확장

### 리플렉션 문제점

- 리플렉션은 컴파일 타임에 직접 호출하는 메서드 호출보다 실행 속도가 느리다.
- 리플렉션을 과도하게 사용하면, 애플리케이션 전체의 성능에 악영향

예외 래핑

- 체크된 예외를 직접 전달하지 않고 이를 InvocationTargetException 으로 감싸서 던진다.
    - 이걸 catch 해서 getCause() 사용해 원래 발생한 예외 확인
- 런타임 예외로 변환
    - 리플렉션 API는 다양한 예외 상황을 모두 고려
    - 호출하는 측에서 이들 체크 예외를 명시적으로 처리하도록 강제합니다.
    - 일부 라이브러리나 유틸리티에서는 이러한 체크 예외들을 런타임 예외로 변환해 처리의 복잡성을 줄이기도 한다.
- 자바 리플렉션 API는 메서드 호출 시 매개변수를 Object 배열로 받으며, 반환값 역시 Object로 취급
    - 리플렉션 호출에서 원시 타입을 다루려면 내부적으로 박싱과 언박싱 과정이 수행
- 원시 타입에 대한 플레이스홀더 클래스 객체(예: int.class)는 원시 타입을 객체처럼 취급하여 메타데이터를 제공하고, 리플렉션이나 클래스 로딩 과정에서 원시 타입 정보를 다룰 수 있도록 해줍니다. 이 객체는 실제로 Class<Integer> 타입으로 간주되며, 이를 통해 원시 타입에 대한 정보를 효과적으로 관리
- **골든해머 기법:**
    
    골든해머란 한 가지 도구나 기법을 모든 문제 해결에 사용하려는 경향을 말합니다. 모든 기능을 리플렉션으로 처리하려 한다면, 단순히 정적 타입 시스템과 명시적 호출로 해결할 수 있는 문제까지 동적 처리를 하게 되어 오히려 문제를 복잡하게 만듭니다.
    
- **내부 미니 프레임워크 구현:**
    
    리플렉션을 기반으로 필요 이상으로 내부 프레임워크나 라이브러리를 구축하는 경우, 실제로는 간단한 기능에 대해 지나치게 복잡한 추상화 계층을 도입하는 결과가 발생합니다. 이러한 구조는 초기 설계 의도와 달리 오히려 디버깅, 성능 최적화, 보안, 타입 안정성 등에서 부정적인 영향을 줄 수 있습니다.