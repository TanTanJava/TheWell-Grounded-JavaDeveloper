# Chapter 4 클래스 파일과 바이트코드

## 4.1 클래스 로딩과 클래스 객체
- .class 파일은 필드, 메서드, 상속 정보, 애너테이션, 기타 메타데이터로 구성된 JVM에서의 타입을 정의한다.

### 4.1.1 로딩과 링킹
- 로딩: 클래스 파일을 읽어 JVM 메모리에 적재하는 과정
- 링킹: 로딩된 클래스 파일이 검증, 준비, 해석 단계를 거쳐 메모리에 적재되는 과정

#### 검증
- 바이트코드가 허용되지 않거나 악의적인 방법으로 스택을 조작하려고 시도하지 않는지 확인
- 모든 분기 명령어에 적절한 대상 명령어가 있는지 확인한다.
- 메서드가 올바른 정적 유형의 메개변수 수로 호출되는지 확인한다.
- 로컬 변수에 적절한 타입의 값만 할당됐는지 확인한다.
- 던질 수 있는 각 예외에 적절한 캐치 핸들러가 있는지 확인한다.

#### 준비
- 메모리를 할당하고 클래스의 정적 변수를 초기화할 수 있도록 준비하는 작업
- 변수를 초기화하거나 JVM 바이트코드를 실행하지는 않음.

#### 해결
- 링킹할 클래스의 상위 유형이 이미 링킹됐는지 확인하고, 그렇지 않은 경우 이 클래스의 링크가 계속되기 전에 해당 타입들을 링킹한다.

#### 초기화
- 모든 정적 변수가 초기화되고 모든 정적 초기화 블록이 실행된다.
- JVM이 새로 로드된 클래스의 바이트코드를 실행한다.
- 런타임에서 클래스를 사용할 수 있으며 클래스의 새로운 인스턴스를 생성할 수 있다.

### 4.1.2 Class 객체
- Class 객체는 일반 자바 객체다. 다른 객체와 마찬가지로 자바 힙에 존재한다.
- 새로운 타입을 사용해서 인스턴스를 생성할 수 있다.
- 타입의 Class 객체에는 상위 타입에 해당하는 Class 객체를 반환하는 getSuperclass()가 제공된다.
- Class 객체는 메서드, 필드, 생성자 등에 대한 간접적인 액세스를 위해 리플렉션 API와 함께 사용할 수 있다.

## 4.2 클래스 로더
- BootstrapClassLoader:
  - JVM을 시작하는 프로세스 초기에 인스턴스화되므로 일반적으로 JVM의 일부로 간주된다.
  - 가장 기본 시스템인 java.base를 로드하는 데 사용된다.
- PlatformClassLoader:
  - 최소한의 시스템이 부트스트랩된 후 플랫폼 클래스로더는 애플리케이션이 의존하는 나머지 플랫폼 모듈을 로드한다.
  - 모든 플랫폼 클래스에 액세스하기 위한 기본 인터페이스다.
  - 내부 클래스의 인스턴스이다.
- ApplicationClassLoader:
  - 가장 널리 사용되는 클래스 로더다.
  - 애플리케이션 클래스를 로드하고 대부분의 최신 자바 환경에서 대부분의 작업을 수행한다.
  - 모듈형 JVM에서 애플리케이션 클래스로더는 자바 8과 이전 버전에서와 같이 더 이상 URLClassLoader의 인스턴스가 아닌 내부 클래스의 인스턴스이다.

### 4.2.1 사용자 정의 클래스 로드
- 사용자 정의 클래스로더도 하나의 자바 타입이므로 일반적으로 상위 클래스로더라고 하는 클래스로더에서 로드해야 한다.
- 클래스로더는 일종의 위임 관계이다.

#### 클래스 로드 중 발생할 수 있는 예외들
- ClassNotFoundException: 클래스를 찾을 수 없을 때 발생
- NoClassDefFoundError: 클래스를 찾았지만 클래스에 대한 정의를 찾지 못함
- JVM은 클래스 로드 시도에 실패할 경우 네거티브 캐싱을 효과적으로 구현해서 로드를 다시 시도하지 않고 대신 오류를 던진다.
- UnsupportedClassVersionError: 클래스 파일이 JVM 버전과 호환되지 않을 때 발생

#### 첫 번째 사용자 정의 클래스로더
- 가장 간단한 형태의 사용자 정의 클래스 로딩은 ClassLoader를 서브클래싱하고 findClass()를 오버라이드 하는 것이다.
- loadClass() 로직을 재사용하고 클래스로더의 복잡성을 줄일 수 있다.

#### 예시: DI 프레임워크
- 시스템 내의 기능 단위에는 적절한 기능을 수행하기 위해 의존하는 의존성과 구성 정보가 있다.
- 많은 객체 시스템에서는 코드로 표현하기 어렵거나 어색한 의존성이 있다.
- 클래스로딩은 두 단계로 나누어 진행된다.
  - 모든 프레임워크 클래스를 로드하고 구성파일의 위치를 main()의 매개변수로 받는다.
  - config.xml 파일의 일관성을 검사하고 오류가 없는지 확인한다.
  - 위 작업들이 성공하면 DI 프레임워크는 필요한 객체를 올바른 순서로 인스턴스화할 수 있다.

#### 예시: 인스트루먼테이션 클래스로더
- 클래스가 로드될 때 바이트코드를 변경해서 추가적인 인스트루먼테이션 정보를 추가하는 클래스로더의 경우
  - 변환된 코드에 대해 테스트 케이스가 실행되면 인스트루먼테이션 코드는 테스트 케이스가 실제로 테스트하는 메서드와 코드 분기를 기록한다.

### 4.2.2 모듈 및 클래스 로딩
- 모듈 시스템은 플랫폼 내에서 상대적으로 낮은 수준의 메커니즘인 클래스 로딩과는 다른 수준에서 작동하도록 설계됐다.
- 모듈해결: 모듈형 JVM에서 실행할 때 런타임은 프로그램을 실행하기 위해 모듈 그래프를 계산하고 첫 번째 단계로 이를 만족시키려고 한다.

## 4.3 클래스 파일 살펴보기
### 4.3.1 javap 소개
- 클래스에 선언된 메서드 확인부터 바이트코드 인쇄에 이르기까지 유용한 작업에서 사용할 수 있다.
- public, protected, default(패키지 내로 제한됨) 메서드를 표시한다.
- -p 스위치는 private 메서드와 필드도 표시한다.

### 4.3.2 메서드 시그니처를 위한 내부 형식
- 타입 기술자
    - B: Byte
    - C: Char(a 16-bit Unicode Character)
    - D: Double
    - F: Float
    - I: Int
    - J: Long
    - L<type name>;: 참조 타입 (예: Ljava/lang/String 문자열의 경우)
    - S: Short
    - V: Void
    - Z: Boolean
    - [: Array-of
- 경우에 따라 타입 기술자가 소스 코드에 나타나는 타입 이름보다 길 수 있다.
- 스위치 -s를 사용하여 시그니처의 타입 기술자를 출력할 수 있다.

### 4.3.3 상수 풀
- 상수 풀은 클래스 파일의 다른 (상수) 요소에서 편리한 바로 가기를 제공하는 영역이다.
- 상수 풀의 정보를 보려면 javap -v를 사용하면 된다.
- 상수 풀 항목
  - Class: 클래스 상수다. 클래스 이름을 가리킨다.
  - Fieldref: 필드를 정의한다. 이 필드의 클래스와 NameAndType을 가리킨다.
  - Methodref: 메서드를 정의한다. 이 필드의 클래스와 NameAndType을 가리킨다.
  - InterfaceMethodref: 인터페이스 메서드를 정의한다. 이 필드의 클래스와 NameAndType을 가리킨다.
  - String: 문자열 상수다. 문자를 저장하는 uft8 항목을 가리킨다.
  - Integer: 정수 상수(4바이트)다.
  - Float: 부동 소수점 상수(4바이트)다.
  - Long: 긴 상수(8바이트)다.
  - Double: 배정밀도 부동 소수점 상수(8바이트)다.
  - NameAndType: 이름과 유형 쌍을 설명한다. 유형은 해당 유형의 유형 설명자를 포함하는 Utf8을 가리킨다.
  - Utf8: Utf8로 인코딩된 문자를 나타내는 바이트 스트림이다.
  - InvokeDynamic: invokedynamic 메커니즘의 일부다.
  - MethodHandle: invokedynamic 메커니즘의 일부다.
  - MethodType: invokedynamic 메커니즘의 일부다.

## 4.4 바이트코드
- 바이트코드는 사람이 읽을 수 있는 소스 코드와 기계 코드의 중간에 있는 프로그램의 중간 표현이다.
- 바이트코드는 자바 소스 코드 파일에서 javac에 의해 생성된다.
- 일부 고급 언어 기능은 컴파일돼 바이트코드에 나타나지 않는다.
- 예를 들어 자바의 루프 구조들은 바이트코드의 분기 명령어로 바뀌면서 사라진다.
- 각 오퍼레이션 코드는 단일 바이트로 표현된다.
- 바이트코드는 '가상의 CPU를 위한 기계어 코드'가 아닌 추상적인 표현이다.
- 바이트코드는 일반적으로 JIT 방식으로 기계어 코드로 추가적으로 컴파일 할 수 있다.

### 4.4.1 클래스 분해하기
- -c 스위치와 함께 javap를 사용하면 클래스를 분해할 수 있다.

### 4.4.2 런타임 환경
- 바이트코드를 이해하려면 JVM이 사용하는 스택 머신의 작동을 이해하는 것이 중요하다.
- 평가 스택은 메서드 내에서 지역적으로 사용되며, 메서드가 호출될 때마다 새로운 평가 스택이 생성된다.
- JVM은 각 자바 스레드마다 호출 스택을 가지고 있으며, 어떤 메서드가 실행됐는지 기록한다.

### 4.4.3 오퍼레이션 코드 소개
- JVM 바이트코드는 각각의 명령어 뒤에 가능한 인수들을 가진 오퍼레이션 코드의 연속으로 구성된다.
- 오퍼레이션 코드 표에는 다음과 같은 네 개의 열이 있다.
  - Name: 이는 오퍼레이션 코드 타입에 대한 일반적인 이름이다. 많은 경우, 여러 관련 오퍼레이션 코드가 유사한 작업을 수행한다.
  - Args: 오퍼레이션 코드가 사용하는 인수들이다. i로 시작하는 인수는 상수 풀이나 로컬 변수표에서 조회 인덱스를 구성하는 데 사용되는 바이트이다.
  - Stack layer: 오퍼레이션 코드가 실행되기 전과 후의 스택 상태를 보여준다. 대괄호 안의 요소는 오퍼레이션 코드의 모든 형태가 해당 요소를 사용하지 않거나 해당 요소가 선택사항임을 나타낸다.
  - Description: 오퍼레이션 코드가 하는 일을 설명한다.

### 4.4.4 load 및 store 오퍼레이션 코드
- 일련의 load와 store 오퍼레이션 코드 그룹은 스택에 값을 로드하거나 조회하는 것과 관련이 있다.
- load, ldc, store, dup, getfield, putfield, getstatic, pustatic

### 4.4.5 산술을 위한 오퍼레이션 코드
- 스택 상단에서 인수를 가져와 필요한 계산을 수행한다.
- 인수는 항상 원시 타입이어야 하며 정확하게 일치해야 한다.
- add, sub, div, mul, (cast)

### 4.4.6 실행 흐름을 제어하기 위한 오퍼레이션 코드
- 실행 흐름은 소수의 원시 오퍼레이션 코드로 처리된다.
- if, goto, tableswitch, lookupswitch

### 4.4.7 Invoke 오퍼레이션 코드
- invoke 오퍼레이션 코드 패밀리는 일반적인 메서드 호출을 처리하기 위한 네 개의 오퍼레이션 코드와 자바 7에 추가된 invokedynamic 오퍼레이션 코드로 구성된다.
- invokestatic, invokevirtual, invokeinterface, invokespecial, invokedynamic

### 4.4.8 플랫폼 관련 작업을 수행하는 오퍼레이션 코드
- 플랫폼 작업 오퍼레이션 코드 집합에는 새로운 객체 인스턴스를 할당하거나 스레드 관련 오퍼레이션 코드가 포함된다.
- new, monitorenter, monitorexit

## 4.5 리플렉션
- 객체지향 시스템에서의 리플렉션은 프로그래밍 환경이 프로그램의 타입과 메서드를 객체로 나타낼 수 있는 개념이다.
- 언어의 동적인 측면
- 정적으로 타입을 알 필요 없이 객체와 작업을 할 수 있다.
- 코드를 작성할 때 존재하지 않았던 타입을 포함한 모든 타입과 작업할 수 있는 라이브러리, 프레임워크, 도구를 만들 수 있다.

### 4.5.1 리플렉션 소개
- 리플렉션은 Method, Field, Constructor, Class 등의 클래스를 사용해 객체의 메서드, 필드, 생성자, 타입을 조사하고 조작하는 것을 의미한다.

### 4.5.2 클래스 로딩과 리플렉션 결합하기

### 4.5.3 리플렉션의 문제점
- 자바 컬렉션 이전에 만들어진 매우 오래된 API로, 배열 타입이 여기저기에 존재한다.
- 어떤 메서드 오버로드를 호출할지 결정하는 것은 쉽지 않다.
- API에는 메서드에 대한 리플렉션적인 접근을 위해 getMethod()와 getDeclaredMethod()라는 서로 다른 두 가지 메서드가 제공된다.
- API는 접근 제어를 무시하는 데 사용할 수 있는 setAccessible() 메서드를 제공한다.
- 리플렉션 호출에 대한 예외 처리가 복잡하다. 체크된 예외가 런타임 예외로 변환된다.
- 원시 타입을 전달하거나 반환하는 리플렉션 호출을 수행하려면 박싱과 언박싱이 필요하다.
- 원시 타입에는 플레이스홀더 클래스 객체가 필요하며, 이는 실제로는 Class<Integer> 타입이다.
- void 메서드에는 java.lang.Void 타입을 도입해야 한다.
- API의 어려운 부분 외에도 자바 리플렉션은 JVM의 JIT 컴파일러에 대한 호환성 부족 등 여러가지 이유로 인해 항상 성능 저하를 겪어 왔다.